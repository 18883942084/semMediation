#setwd("location") #Working directory
set.seed(123)#Standardizes the numbers generated by rnorm; see Chapter 5
N  <- 100 #Number of participants; graduate students
X  <- abs(rnorm(N, 6, 4)) #IV; Hours of sleep
X1 <- abs(rnorm(N, 60, 30)) #Adding some systematic variance for our DV
Z  <- rnorm(N, 30, 8) #Moderator; Ounces of coffee consumed
Y  <- abs((-0.8*X) * (0.2*Z) - 0.5*X - 0.4*X1 + 10 + rnorm(N, 0, 3)) #DV; Attention Paid
Moddata <- data.frame(X, X1, Z, Y)

summary(Moddata)

Xc    <- c(scale(X, center=TRUE, scale=FALSE)) #Centering IV; hours of sleep
Zc    <- c(scale(Z,  center=TRUE, scale=FALSE)) #Centering moderator; coffee consumption

#Moderation "By Hand"
fitMod <- lm(Y ~ Xc + Zc + Xc*Zc) #Model interacts IV & moderator
summary(fitMod)
coef(summary(fitMod))

library(gvlma)
gvlma(fitMod)

ztable::ztable(fitMod)

library(rockchalk)
ps  <- plotSlopes(fitMod, plotx="Xc", modx="Zc", xlab = "Sleep", ylab = "Attention Paid", modxVals = "std.dev")
ggiraphExtra::ggPredict(fitMod)

### Modertated mediation

set.seed(42) #This makes sure that everyone gets the same numbers generated through rnorm function
a1 = -.59 #Set the path a1 strength (effect of X on M)
a2 = -.17 #Set path a2 strength (effect of Z on M)
a3 = .29 #Set path a3 strength (interaction between X and Z on M)
b = .59 #Set path b strength (effect of M on Y)
cdash1 = .27 #Set path c'1 strength (effect of X on Y)
cdash2 = .01 #Set path c'2 strength (effect of Z on Y)
cdash3 = -.01 #Set path c'3 strength (interaction betwee X and Z on Y)

n <- 200 #Set sample size
X <- rnorm(n, 7, 1) #IV: Time spent in grad school (M = 7, SD = 1)
Z <- rnorm(n, 5, 1) #Moderator: Time spent (hours per week) with Professor Demos in class or in office hours (M = 5, SD = 1)
M <- a1*X + a2*Z + a3*X*Z + rnorm(n, 0, .1) #Mediator: Number of publications in grad school
#The mediator variable is created as a function of the IV, moderator, and their interaction with some random noise thrown in the mix
Y <- cdash1*X + cdash2*Z + cdash3*X*Z + b*M + rnorm(n, 0, .1) #DV: Number of job offers
#Similar to the mediator, the DV is a function of the IV, moderator, their interaction, and the mediator with some random noise thrown in the mix

Success.ModMed <- data.frame(jobs = Y, time = X, pubs = M, alex = Z)

library(psych) #Helpful for common psych descriptive statistics

str(Success.ModMed)
describe(Success.ModMed)

#Scale returns a matrix so we have to make it a vector by indexing one column
scale(Success.ModMed$time, center = TRUE, scale = FALSE)[,]

Success.ModMed$time.c <- scale(Success.ModMed$time, center = TRUE, scale = FALSE)[,]
Success.ModMed$alex.c <- scale(Success.ModMed$alex, center = TRUE, scale = FALSE)[,]

library(mediation)

Mod.Med.Model.1<-lm(pubs ~ time.c*alex.c, data = Success.ModMed)
summary(Mod.Med.Model.1)
Mod.Med.Model.2<-lm(jobs ~ time.c*alex.c + pubs, data = Success.ModMed)
summary(Mod.Med.Model.2)


mediate <- mediation::mediate
low.alex<-mean(Success.ModMed$alex.c)-sd(Success.ModMed$alex.c)
low.alex

Mod.Med.LowAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2,
                           covariates = list(alex.c = low.alex), boot = TRUE,
                           boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")

summary(Mod.Med.LowAlex)
plot(Mod.Med.LowAlex, xlim = 0:1)


high.alex<-mean(Success.ModMed$alex.c)+sd(Success.ModMed$alex.c)

high.alex
Mod.Med.HighAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2,
                            covariates = list(alex.c = high.alex), boot = TRUE,
                            boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")

summary(Mod.Med.HighAlex)
plot(Mod.Med.HighAlex, xlim = 0:1)

Mod.Med.TestAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2, boot = TRUE,
                            boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")   #We don't specify anything about the moderator in this code yet

test.modmed(Mod.Med.TestAlex, covariates.1 = list(alex.c = low.alex),
            covariates.2 = list(alex.c = high.alex), sims = 10) #Here we specify both levels of the moderator that we want to test


Mod.Med.Lavaan <- '
#Regressions
#These are the same regression equations from our previous example
#Except in this code we are naming the coefficients that are produced from the regression equations
#E.g., the regression coefficient for the effect of time on pubs is named "a1"
pubs ~ a1*time.c + a2*alex.c + a3*time.c:alex.c
jobs ~ cdash1*time.c + cdash2*alex.c + cdash3*time.c:alex.c + b1*pubs

#Mean of centered alex (for use in simple slopes)
#This is making a coefficient labeled "alex.c.mean" which equals the intercept because of the "1"
#(Y~1) gives you the intercept, which is the mean for our alex.c variable
alex.c ~ alex.c.mean*1

#Variance of centered alex (for use in simple slopes)
#This is making a coefficient labeled "alex.c.var" which equals the variance because of the "~~"
#Two tildes separating the same variable gives you the variance
alex.c ~~ alex.c.var*alex.c

#Indirect effects conditional on moderator (a1 + a3*ModValue)*b1
indirect.SDbelow := (a1 + a3*(alex.c.mean-sqrt(alex.c.var)))*b1
indirect.SDabove := (a1 + a3*(alex.c.mean+sqrt(alex.c.var)))*b1

#Direct effects conditional on moderator (cdash1 + cdash3*ModValue)
#We have to do it this way because you cannot call the mean and sd functions in lavaan package
direct.SDbelow := cdash1 + cdash3*(alex.c.mean-sqrt(alex.c.var))
direct.SDabove := cdash1 + cdash3*(alex.c.mean+sqrt(alex.c.var))

#Total effects conditional on moderator
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.SDabove := direct.SDabove + indirect.SDabove

#Proportion mediated conditional on moderator
#To match the output of "mediate" package
prop.mediated.SDbelow := indirect.SDbelow / total.SDbelow
prop.mediated.SDabove := indirect.SDabove / total.SDabove

#Index of moderated mediation
#An alternative way of testing if conditional indirect effects are significantly different from each other
index.mod.med := a3*b1
'
Mod.Med.SEM <- sem(model = Mod.Med.Lavaan,
                   data = Success.ModMed,
                   se = "bootstrap",
                   bootstrap = 10)
summary(Mod.Med.SEM,
        fit.measures = FALSE,
        standardize = TRUE,
        rsquare = TRUE)


#Bootstraps
parameterEstimates(Mod.Med.SEM,
                   boot.ci.type = "bca.simple",
                   level = .95, ci = TRUE,
                   standardized = FALSE)[c(19:27),c(4:10)] #We index the matrix to only display columns we are interested in

