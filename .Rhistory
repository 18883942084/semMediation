res1=res1[!(res1$rhs %in% delVars),]
}
if(nrow(res1)>0){
for(i in 1:nrow(res1)){
if(res1$op[i]=="=~") {
if(res1$rhs[i] %in% H1vars) {
temp=paste0(res1$rhs[i],"->",res1$lhs[i],"[dir=back ")
} else{
temp=paste0(res1$lhs[i],"->",res1$rhs[i],"[")
}
} else {
if(res1$op[i]=="~~") {
if(df1$group1[df1$text==res1$rhs[i]]==df1$group1[df1$text==res1$lhs[i]]){
if(df1$x1[df1$text==res1$rhs[i]]==min(df1$x1)){
temp=paste0(res1$rhs[i],":w ->",res1$lhs[i],":w [")
} else if(df1$x1[df1$text==res1$rhs[i]]==max(df1$x1)){
temp=paste0(res1$rhs[i],":e ->",res1$lhs[i],":e [")
} else{
temp=paste0(res1$rhs[i],"->",res1$lhs[i],"[")
}
} else{
temp=paste0(res1$rhs[i],"->",res1$lhs[i],"[")
}
temp=paste0(temp,"dir=both constraint=false ")
} else{
temp=paste0(res1$rhs[i],"->",res1$lhs[i],"[")
}
}
equation <- equation %>% paste0(temp)
if(is.na(res1$pvalue[i])) equation <- equation %>% paste0("style=dashed ")
else if(res1$pvalue[i] >=0.05) equation <- equation %>% paste0("style=dashed ")
temp=""
if(whatLabels=="std") temp=sprintf("%.02f",res1$std.all[i])
else if(whatLabels=="est") temp=sprintf("%.02f",res1$est[i])
else if(whatLabels=="name") temp=res1$label[i]
if(!is.null(temp)) {
if(temp!="") equation <- equation %>% paste0("label=",temp)
}
equation <- equation %>% paste0("]\n")
}
}
df1
library(semMediation)
cat(makeDiagram(fit))
semDiagram(fit)
df=fit2df(fit)
df=addpos(df)
df$text=removePeriod(df$text)
df
df1=addPos2(df)
df1
df=fit2df(fit)
df=addpos(df)
df$text=removePeriod(df$text)
df
df$x1=floor(df$x)
df
HGroups=unique(df$group1[stringr::str_detect(df$group1,"H")])
MGroups=unique(df$group1[stringr::str_detect(df$group1,"M")])
HMGroups=c(HGroups,MGroups)
upper<-lower<-0
for(i in seq_along(HGroups)){
# cat("i=",i,",upper=",upper,",lower=",lower,"\n")
temp=df$text[df$group1 == HGroups[i]]
add=1:length(temp)
mpos=ceiling(length(temp)/2)+1
mpos
if(length(temp)%%2==0){
add[(length(temp)/2+1):length(temp)]=add[(length(temp)/2+1):length(temp)]+1
}
df$x1[df$group1== HGroups[i]]=add+ifelse(upper<=lower,upper,lower)
df$x1[df$group1== paste0("M",i)]=mpos+ifelse(upper<=lower,upper,lower)
df$y[df$group1== paste0("M",i)]=ifelse(upper<=lower,1,2)
if(upper<=lower) {
upper=upper+add[length(add)]
df$y[df$group1== HGroups[i]]=1
} else{
lower=lower+add[length(add)]
df$y[df$group1== HGroups[i]]=2
}
}
df
diff=upper-lower
diff
if(diff>=2){
if(upper>lower){
df$x1[df$group1 %in% HMGroups & df$y==2]=df$x1[df$group1 %in% HMGroups & df$y==2]+diff%/%2
}
}
diff1=max(upper,lower)-max(df$x)
if(diff1>0) df$x1[df$x>=(max(df$x)-1)]=df$x1[df$x>=(max(df$x)-1)]+diff1+1
if((length(unique(df$x1))==2) &(max(df$x1)==1)){
df$x1[df$x1==1]=4
}
df
df$y[df$group1=="X"]
df$y[df$group1=="X"]=1:length(df$y[df$group1=="X"])
df
df$y[df$group1=="Y"]=1:length(df$y[df$group1=="Y"])
df
library(semMediation)
model <- 'mpg ~ cyl + disp + hp
qsec ~ disp + hp + wt'
fit <- sem(model, data = mtcars)
summary(fit)
lavaanPlot(model = fit, node_options = list(shape = "box", fontname = "Helvetica"),
edge_options = list(color = "grey"),
coefs = TRUE,cov=TRUE)
mediationPlot(fit)
semDiagram(fit)
cat(makeDiagram(fit))
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
model <- 'mpg ~ cyl + disp + hp
qsec ~ disp + hp + wt'
fit <- sem(model, data = mtcars)
summary(fit)
lavaanPlot(model = fit, node_options = list(shape = "box", fontname = "Helvetica"),
edge_options = list(color = "grey"),
coefs = TRUE,cov=TRUE)
mediationPlot(fit)
require(lavaan)
require(semPlot)
require(semMediation)
require(DiagrammeR)
require(lavaanPlot)
model <- 'mpg ~ cyl + disp + hp
qsec ~ disp + hp + wt'
fit <- sem(model, data = mtcars)
summary(fit)
lavaanPlot(model = fit, node_options = list(shape = "box", fontname = "Helvetica"),
edge_options = list(color = "grey"),
coefs = TRUE,cov=TRUE)
mediationPlot(fit)
semDiagram(fit)
cat(makeDiagram(fit))
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
library(semMediation)
library(semMediation)
HS.model <- ' visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
'
fit <- cfa(HS.model, data=HolzingerSwineford1939)
lavaanPlot(model = fit, edge_options = list(color = "grey"))
require(lavaan)
require(semPlot)
require(semMediation)
require(DiagrammeR)
require(lavaanPlot)
set.seed(1234)
X1 <- rnorm(100)
X2 <- c(rnorm(50),rnorm(50))
M1 <- 0.5*X1 + 0.5*X2 +rnorm(100)
M2 <-0.6*X1 +0.4*X2+rnorm(100)
Y1 <- 0.3*M1 + 0.4*M2 + rnorm(100)
Y2 <- 0.1*M1 + 0.5*M2 + rnorm(100)
data <- data.frame(X1 = X1, X2 = X2, Y1 = Y1, Y2 = Y2, M1 = M1, M2 = M2)
str(data)
model=
"Y1~X1+X2+X1:X2
"
model1=makeEquation(X="X1",M=c("M1","M2"),Y="Y1")
model=paste0(model,model1)
cat(model)
fit=sem(model,data=data)
model=
"Y1~X1+X2+X1:X2
"
cat(model)
fit=sem(model,data=data)
fit=sem(model1,data=data)
summary(fit)
semPaths(fit,whatLabels = "std")
mediationPlot(fit)
semDiagram(fit)
lavaanPlot(model=fit,coef=TRUE)
cat(makeDiagram(fit))
semDiagram(fit)
HS.model <- ' visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
'
fit <- cfa(HS.model, data=HolzingerSwineford1939)
lavaanPlot(model = fit, edge_options = list(color = "grey"))
semDiagram(fit)
library(semMediation)
HS.model <- ' visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
'
fit <- cfa(HS.model, data=HolzingerSwineford1939)
lavaanPlot(model = fit, edge_options = list(color = "grey"))
semDiagram(fit)
fit <- cfa(HS.model, data=HolzingerSwineford1939)
lavaanPlot(model = fit, edge_options = list(color = "grey"))
semDiagram(fit)
HS.model <- ' visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
'
fit <- cfa(HS.model, data=HolzingerSwineford1939)
labels = list(visual = "Visual Ability", textual = "Textual Ability", speed = "Speed Ability")
# significant standardized paths only
lavaanPlot(model = fit,
labels = labels,
graph_options = list(rankdir="RL"),
node_options = list(shape = "box", fontname = "Helvetica"),
edge_options = list(color = "gray"),
coefs = TRUE)
semPaths(fit,whatLabels = "std")
semDiagram(fit,labels = labels,
nodeOptions = list(color = "blue", fontname = "Helvetica"),
edgeOptions = list(color = "gray"),
whatLabels="none")
cat(makeDiagram(fit))
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
model='
knowledge =~ general+symptoms+treatmt
empathy =~ cognitiv+emotion+disposit+attitude
intervention =~ classrm+instruct
'
mediationModel=makeEquation(X="knowledge",M="empathy",Y="intervention")
model=paste0(model,mediationModel)
cat(model)
fit=sem(model,data=ADHD)
summary(fit,standardized= TRUE ,fit.measures= FALSE ,rsquare= FALSE ,modindices= FALSE )
semPaths(fit,rotation=2,whatLabels = "std")
#mediationPlot(fit,whatLabels = "name",residuals=FALSE)
mediationPlot(fit,width=8,height=4,whatLabels = "std",residuals = FALSE,base_size=4)
lavaanPlot(name="plot",fit)
semDiagram(fit)
lavaanPlot(name="plot",fit)
semDiagram(fit)
#mediationPlot(fit,whatLabels = "name",residuals=FALSE)
mediationPlot(fit,width=8,height=4,whatLabels = "std",residuals = FALSE,base_size=4)
semPaths(fit,rotation=2,whatLabels = "std")
# 사용 패키지
library(car)
library(jtools)
library(lavaan)
library(QuantPsyc)
library(lavaanPlot)
# setwd("E:/mod")
rawData<-read.csv("moddata1.csv")
names(rawData)
newData <- rawData
# 평균중심화
newData$centered.x <- scale(rawData$x, center =T, scale = T)
newData$centered.mod <- scale(rawData$mod, center =T, scale = T)
newData$centered.xmod <- newData$centered.x*newData$centered.mod
# 평균중심화 하지 않은 조절효과
mod1 <- lm(y ~ x + mod + x:mod, newData)
ggiraphExtra::ggPredict(mod1)
# 평균중심화 한 조절효과
mod2 <- lm(y ~ centered.x + centered.mod + centered.x:centered.mod, newData)
ggiraphExtra::ggPredict(mod2)
# 평균중심화 하지 않은 조절효과
mod1 <- lm(y ~ x + mod + x:mod, newData)
ggiraphExtra::ggPredict(mod1)
# 평균중심화 한 조절효과
mod2 <- lm(y ~ centered.x + centered.mod + centered.x:centered.mod, newData)
ggiraphExtra::ggPredict(mod2)
mod2 <- lm(y ~ centered.x * centered.mod, newData)
ggiraphExtra::ggPredict(mod2)
newData
ggiraphExtra::ggPredict(mod2)
# lavaan에서의 조절효과(조절변수가 연속형인 경우)
sem.mod1 <- '
y ~ x + mod + centered.xmod
'
fit <- sem(sem.mod1, newData)
summary(fit, std=T, fit=T)
# lavaanPlot
labels <- list(x = "교육기간", mod = "학급인원수", centeredxmod = "교육기간X학급인원수", y = "월수입")
lavaanPlot(model=fit)
semDiagram(fit)
lavaanPlot(model=fit, labels = labels, coef =T, stand = T, stars = "regress",cov=T)
semDiagram(fit,labels = labels,nodeOptions=list(width=2),whatLabels="std")
cat(makeDiagram(fit,labels = labels,nodeOptions=list(width=2),whatLabels="std"))
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
semDiagram(fit,labels = labels,nodeOptions=list(width=2),whatLabels="std")
library(semMediation)
semDiagram(fit,labels = labels,nodeOptions=list(width=2),whatLabels="std")
# setwd("E:/mod")
rawData<-read.csv("moddata1.csv")
names(rawData)
newData <- rawData
# QuantPsyc 패키지를 이용한 조절효과 분석
lm.mod1 <- moderate.lm(x, mod, y, newData, mc = T)
summary(lm.mod1)
# setwd("E:/mod")
rawData<-read.csv("moddata1.csv")
names(rawData)
newData <- rawData
# 평균중심화
newData$centered.x <- scale(rawData$x, center =T, scale = T)
newData$centered.mod <- scale(rawData$mod, center =T, scale = T)
newData$centered.xmod <- newData$centered.x*newData$centered.mod
# 평균중심화 하지 않은 조절효과
mod1 <- lm(y ~ x + mod + x:mod, newData)
summary(mod1)
# QuantPsyc 패키지를 이용한 조절효과 분석
lm.mod1 <- moderate.lm(x, mod, y, newData, mc = T)
summary(lm.mod1)
ggPredict(mod1)
ggiraphExtra::ggPredict(mod1)
x=1:10
scale(x)
#setwd("location") #Working directory
set.seed(123)#Standardizes the numbers generated by rnorm; see Chapter 5
N  <- 100 #Number of participants; graduate students
X  <- abs(rnorm(N, 6, 4)) #IV; Hours of sleep
X1 <- abs(rnorm(N, 60, 30)) #Adding some systematic variance for our DV
Z  <- rnorm(N, 30, 8) #Moderator; Ounces of coffee consumed
Y  <- abs((-0.8*X) * (0.2*Z) - 0.5*X - 0.4*X1 + 10 + rnorm(N, 0, 3)) #DV; Attention Paid
Moddata <- data.frame(X, X1, Z, Y)
summary(Moddata)
summary(Moddata)
Xc    <- c(scale(X, center=TRUE, scale=FALSE)) #Centering IV; hours of sleep
Zc    <- c(scale(Z,  center=TRUE, scale=FALSE)) #Centering moderator; coffee consumption
fitMod <- lm(Y ~ Xc + Zc + Xc*Zc) #Model interacts IV & moderator
summary(fitMod)
coef(summary(fitMod))
gvlma(fitMod)
library(gvlma)
install.packages("gvlma")
library(gvlma)
gvlma(fitMod)
library(rockchalk)
ps  <- plotSlopes(fitMod, plotx="Xc", modx="Zc", xlab = "Sleep", ylab = "Attention Paid", modxVals = "std.dev")
ggiraphExtra::ggPredict(fitMod)
ps  <- plotSlopes(fitMod, plotx="Xc", modx="Zc", xlab = "Sleep", ylab = "Attention Paid", modxVals = "std.dev")
ggiraphExtra::ggPredict(fitMod)
ps  <- plotSlopes(fitMod, plotx="Xc", modx="Zc", xlab = "Sleep", ylab = "Attention Paid", modxVals = "std.dev")
ggiraphExtra::ggPredict(fitMod)
gvlma(fitMod)
ztable::ztable(fitMod)
summary(fitMod)
set.seed(42) #This makes sure that everyone gets the same numbers generated through rnorm function
a1 = -.59 #Set the path a1 strength (effect of X on M)
a2 = -.17 #Set path a2 strength (effect of Z on M)
a3 = .29 #Set path a3 strength (interaction between X and Z on M)
b = .59 #Set path b strength (effect of M on Y)
cdash1 = .27 #Set path c'1 strength (effect of X on Y)
cdash2 = .01 #Set path c'2 strength (effect of Z on Y)
cdash3 = -.01 #Set path c'3 strength (interaction betwee X and Z on Y)
Success.ModMed <- data.frame(jobs = Y, time = X, pubs = M, alex = Z)
n <- 200 #Set sample size
X <- rnorm(n, 7, 1) #IV: Time spent in grad school (M = 7, SD = 1)
Z <- rnorm(n, 5, 1) #Moderator: Time spent (hours per week) with Professor Demos in class or in office hours (M = 5, SD = 1)
M <- a1*X + a2*Z + a3*X*Z + rnorm(n, 0, .1) #Mediator: Number of publications in grad school
#The mediator variable is created as a function of the IV, moderator, and their interaction with some random noise thrown in the mix
Y <- cdash1*X + cdash2*Z + cdash3*X*Z + b*M + rnorm(n, 0, .1) #DV: Number of job offers
Success.ModMed <- data.frame(jobs = Y, time = X, pubs = M, alex = Z)
library(psych) #Helpful for common psych descriptive statistics
str(Success.ModMed)
round(describe(Success.ModMed)[,c(2:5,8,9,13)], 2)
library(psych) #Helpful for common psych descriptive statistics
round(describe(Success.ModMed)[,c(2:5,8,9,13)], 2)
str(Success.ModMed)
describe(Success.ModMed)
describe(Success.ModMed)[,c(2:5,8,9,13)]
describe(Success.ModMed)
describe(Success.ModMed)[,c(2:5)]
describe(Success.ModMed)[c(2:5)]
str(describe(Success.ModMed))
describe(Success.ModMed)[2:5]
describe(Success.ModMed)
str(Success.ModMed)
library(mediation)
install.packages("mediation")
library(mediation)
Mod.Med.Model.1<-lm(pubs ~ time.c*alex.c, data = Success.ModMed)
Success.ModMed$time.c <- scale(Success.ModMed$time, center = TRUE, scale = FALSE)[,] #Scale returns a matrix so we have to make it a vector by indexing one column
Success.ModMed$alex.c <- scale(Success.ModMed$alex, center = TRUE, scale = FALSE)[,]
#Scale returns a matrix so we have to make it a vector by indexing one column
Success.ModMed$time.c <- scale(Success.ModMed$time, center = TRUE, scale = FALSE)[,]
Success.ModMed$alex.c <- scale(Success.ModMed$alex, center = TRUE, scale = FALSE)[,]
#Scale returns a matrix so we have to make it a vector by indexing one column
scale(Success.ModMed$time, center = TRUE, scale = FALSE)
#Scale returns a matrix so we have to make it a vector by indexing one column
str(scale(Success.ModMed$time, center = TRUE, scale = FALSE))
#Scale returns a matrix so we have to make it a vector by indexing one column
scale(Success.ModMed$time, center = TRUE, scale = FALSE)[]
#Scale returns a matrix so we have to make it a vector by indexing one column
scale(Success.ModMed$time, center = TRUE, scale = FALSE)[,]
#Scale returns a matrix so we have to make it a vector by indexing one column
scale(Success.ModMed$time, center = TRUE, scale = FALSE)
#Scale returns a matrix so we have to make it a vector by indexing one column
scale(Success.ModMed$time, center = TRUE, scale = FALSE)[,]
library(mediation)
Mod.Med.Model.1<-lm(pubs ~ time.c*alex.c, data = Success.ModMed)
summary(Mod.Med.Model.1)
Mod.Med.Model.2<-lm(jobs ~ time.c*alex.c + pubs, data = Success.ModMed)
summary(Mod.Med.Model.2)
Mod.Med.Model.1<-lm(pubs ~ time.c*alex.c, data = Success.ModMed)
summary(Mod.Med.Model.1)
Mod.Med.Model.2<-lm(jobs ~ time.c*alex.c + pubs, data = Success.ModMed)
summary(Mod.Med.Model.2)
mediate <- mediation::mediate
low.alex<-mean(Success.ModMed$alex.c)-sd(Success.ModMed$alex.c)
low.alex
Mod.Med.LowAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2,
covariates = list(alex.c = low.alex), boot = TRUE,
boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")
summary(Mod.Med.LowAlex)
plot(Mod.Med.LowAlex, xlim = 0:1)
high.alex<-mean(Success.ModMed$alex.c)+sd(Success.ModMed$alex.c)
high.alex
Mod.Med.HighAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2,
covariates = list(alex.c = high.alex), boot = TRUE,
boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")
summary(Mod.Med.HighAlex)
plot(Mod.Med.HighAlex, xlim = 0:1)
summary(Mod.Med.HighAlex)
Mod.Med.TestAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2, boot = TRUE,
boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")   #We don't specify anything about the moderator in this code yet
test.modmed(Mod.Med.TestAlex, covariates.1 = list(alex.c = low.alex),
covariates.2 = list(alex.c = high.alex), sims = 10) #Here we specify both levels of the moderator that we want to test
Mod.Med.Lavaan <- '
#Regressions
#These are the same regression equations from our previous example
#Except in this code we are naming the coefficients that are produced from the regression equations
#E.g., the regression coefficient for the effect of time on pubs is named "a1"
pubs ~ a1*time.c + a2*alex.c + a3*time.c:alex.c
jobs ~ cdash1*time.c + cdash2*alex.c + cdash3*time.c:alex.c + b1*pubs
#Mean of centered alex (for use in simple slopes)
#This is making a coefficient labeled "alex.c.mean" which equals the intercept because of the "1"
#(Y~1) gives you the intercept, which is the mean for our alex.c variable
alex.c ~ alex.c.mean*1
#Variance of centered alex (for use in simple slopes)
#This is making a coefficient labeled "alex.c.var" which equals the variance because of the "~~"
#Two tildes separating the same variable gives you the variance
alex.c ~~ alex.c.var*alex.c
#Indirect effects conditional on moderator (a1 + a3*ModValue)*b1
indirect.SDbelow := (a1 + a3*(alex.c.mean-sqrt(alex.c.var)))*b1
indirect.SDabove := (a1 + a3*(alex.c.mean+sqrt(alex.c.var)))*b1
#Direct effects conditional on moderator (cdash1 + cdash3*ModValue)
#We have to do it this way because you cannot call the mean and sd functions in lavaan package
direct.SDbelow := cdash1 + cdash3*(alex.c.mean-sqrt(alex.c.var))
direct.SDabove := cdash1 + cdash3*(alex.c.mean+sqrt(alex.c.var))
#Total effects conditional on moderator
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.SDabove := direct.SDabove + indirect.SDabove
#Proportion mediated conditional on moderator
#To match the output of "mediate" package
prop.mediated.SDbelow := indirect.SDbelow / total.SDbelow
prop.mediated.SDabove := indirect.SDabove / total.SDabove
#Index of moderated mediation
#An alternative way of testing if conditional indirect effects are significantly different from each other
index.mod.med := a3*b1
'
Mod.Med.SEM <- sem(model = Mod.Med.Lavaan,
data = Success.ModMed,
se = "bootstrap",
bootstrap = 10)
summary(Mod.Med.SEM,
fit.measures = FALSE,
standardize = TRUE,
rsquare = TRUE)
#Bootstraps
parameterEstimates(Mod.Med.SEM,
boot.ci.type = "bca.simple",
level = .95, ci = TRUE,
standardized = FALSE)[c(19:27),c(4:10)] #We index the matrix to only display columns we are interested in
