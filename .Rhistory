textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
'
fit <- cfa(HS.model, data=HolzingerSwineford1939)
lavaanPlot(model = fit, edge_options = list(color = "grey"))
semDiagram(fit)
fit <- cfa(HS.model, data=HolzingerSwineford1939)
lavaanPlot(model = fit, edge_options = list(color = "grey"))
semDiagram(fit)
HS.model <- ' visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
'
fit <- cfa(HS.model, data=HolzingerSwineford1939)
labels = list(visual = "Visual Ability", textual = "Textual Ability", speed = "Speed Ability")
# significant standardized paths only
lavaanPlot(model = fit,
labels = labels,
graph_options = list(rankdir="RL"),
node_options = list(shape = "box", fontname = "Helvetica"),
edge_options = list(color = "gray"),
coefs = TRUE)
semPaths(fit,whatLabels = "std")
semDiagram(fit,labels = labels,
nodeOptions = list(color = "blue", fontname = "Helvetica"),
edgeOptions = list(color = "gray"),
whatLabels="none")
cat(makeDiagram(fit))
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
model='
knowledge =~ general+symptoms+treatmt
empathy =~ cognitiv+emotion+disposit+attitude
intervention =~ classrm+instruct
'
mediationModel=makeEquation(X="knowledge",M="empathy",Y="intervention")
model=paste0(model,mediationModel)
cat(model)
fit=sem(model,data=ADHD)
summary(fit,standardized= TRUE ,fit.measures= FALSE ,rsquare= FALSE ,modindices= FALSE )
semPaths(fit,rotation=2,whatLabels = "std")
#mediationPlot(fit,whatLabels = "name",residuals=FALSE)
mediationPlot(fit,width=8,height=4,whatLabels = "std",residuals = FALSE,base_size=4)
lavaanPlot(name="plot",fit)
semDiagram(fit)
lavaanPlot(name="plot",fit)
semDiagram(fit)
#mediationPlot(fit,whatLabels = "name",residuals=FALSE)
mediationPlot(fit,width=8,height=4,whatLabels = "std",residuals = FALSE,base_size=4)
semPaths(fit,rotation=2,whatLabels = "std")
# 사용 패키지
library(car)
library(jtools)
library(lavaan)
library(QuantPsyc)
library(lavaanPlot)
# setwd("E:/mod")
rawData<-read.csv("moddata1.csv")
names(rawData)
newData <- rawData
# 평균중심화
newData$centered.x <- scale(rawData$x, center =T, scale = T)
newData$centered.mod <- scale(rawData$mod, center =T, scale = T)
newData$centered.xmod <- newData$centered.x*newData$centered.mod
# 평균중심화 하지 않은 조절효과
mod1 <- lm(y ~ x + mod + x:mod, newData)
ggiraphExtra::ggPredict(mod1)
# 평균중심화 한 조절효과
mod2 <- lm(y ~ centered.x + centered.mod + centered.x:centered.mod, newData)
ggiraphExtra::ggPredict(mod2)
# 평균중심화 하지 않은 조절효과
mod1 <- lm(y ~ x + mod + x:mod, newData)
ggiraphExtra::ggPredict(mod1)
# 평균중심화 한 조절효과
mod2 <- lm(y ~ centered.x + centered.mod + centered.x:centered.mod, newData)
ggiraphExtra::ggPredict(mod2)
mod2 <- lm(y ~ centered.x * centered.mod, newData)
ggiraphExtra::ggPredict(mod2)
newData
ggiraphExtra::ggPredict(mod2)
# lavaan에서의 조절효과(조절변수가 연속형인 경우)
sem.mod1 <- '
y ~ x + mod + centered.xmod
'
fit <- sem(sem.mod1, newData)
summary(fit, std=T, fit=T)
# lavaanPlot
labels <- list(x = "교육기간", mod = "학급인원수", centeredxmod = "교육기간X학급인원수", y = "월수입")
lavaanPlot(model=fit)
semDiagram(fit)
lavaanPlot(model=fit, labels = labels, coef =T, stand = T, stars = "regress",cov=T)
semDiagram(fit,labels = labels,nodeOptions=list(width=2),whatLabels="std")
cat(makeDiagram(fit,labels = labels,nodeOptions=list(width=2),whatLabels="std"))
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
DiagrammeR::grViz("test.gv")
semDiagram(fit,labels = labels,nodeOptions=list(width=2),whatLabels="std")
library(semMediation)
semDiagram(fit,labels = labels,nodeOptions=list(width=2),whatLabels="std")
# setwd("E:/mod")
rawData<-read.csv("moddata1.csv")
names(rawData)
newData <- rawData
# QuantPsyc 패키지를 이용한 조절효과 분석
lm.mod1 <- moderate.lm(x, mod, y, newData, mc = T)
summary(lm.mod1)
# setwd("E:/mod")
rawData<-read.csv("moddata1.csv")
names(rawData)
newData <- rawData
# 평균중심화
newData$centered.x <- scale(rawData$x, center =T, scale = T)
newData$centered.mod <- scale(rawData$mod, center =T, scale = T)
newData$centered.xmod <- newData$centered.x*newData$centered.mod
# 평균중심화 하지 않은 조절효과
mod1 <- lm(y ~ x + mod + x:mod, newData)
summary(mod1)
# QuantPsyc 패키지를 이용한 조절효과 분석
lm.mod1 <- moderate.lm(x, mod, y, newData, mc = T)
summary(lm.mod1)
ggPredict(mod1)
ggiraphExtra::ggPredict(mod1)
x=1:10
scale(x)
#setwd("location") #Working directory
set.seed(123)#Standardizes the numbers generated by rnorm; see Chapter 5
N  <- 100 #Number of participants; graduate students
X  <- abs(rnorm(N, 6, 4)) #IV; Hours of sleep
X1 <- abs(rnorm(N, 60, 30)) #Adding some systematic variance for our DV
Z  <- rnorm(N, 30, 8) #Moderator; Ounces of coffee consumed
Y  <- abs((-0.8*X) * (0.2*Z) - 0.5*X - 0.4*X1 + 10 + rnorm(N, 0, 3)) #DV; Attention Paid
Moddata <- data.frame(X, X1, Z, Y)
summary(Moddata)
summary(Moddata)
Xc    <- c(scale(X, center=TRUE, scale=FALSE)) #Centering IV; hours of sleep
Zc    <- c(scale(Z,  center=TRUE, scale=FALSE)) #Centering moderator; coffee consumption
fitMod <- lm(Y ~ Xc + Zc + Xc*Zc) #Model interacts IV & moderator
summary(fitMod)
coef(summary(fitMod))
gvlma(fitMod)
library(gvlma)
install.packages("gvlma")
library(gvlma)
gvlma(fitMod)
library(rockchalk)
ps  <- plotSlopes(fitMod, plotx="Xc", modx="Zc", xlab = "Sleep", ylab = "Attention Paid", modxVals = "std.dev")
ggiraphExtra::ggPredict(fitMod)
ps  <- plotSlopes(fitMod, plotx="Xc", modx="Zc", xlab = "Sleep", ylab = "Attention Paid", modxVals = "std.dev")
ggiraphExtra::ggPredict(fitMod)
ps  <- plotSlopes(fitMod, plotx="Xc", modx="Zc", xlab = "Sleep", ylab = "Attention Paid", modxVals = "std.dev")
ggiraphExtra::ggPredict(fitMod)
gvlma(fitMod)
ztable::ztable(fitMod)
summary(fitMod)
set.seed(42) #This makes sure that everyone gets the same numbers generated through rnorm function
a1 = -.59 #Set the path a1 strength (effect of X on M)
a2 = -.17 #Set path a2 strength (effect of Z on M)
a3 = .29 #Set path a3 strength (interaction between X and Z on M)
b = .59 #Set path b strength (effect of M on Y)
cdash1 = .27 #Set path c'1 strength (effect of X on Y)
cdash2 = .01 #Set path c'2 strength (effect of Z on Y)
cdash3 = -.01 #Set path c'3 strength (interaction betwee X and Z on Y)
Success.ModMed <- data.frame(jobs = Y, time = X, pubs = M, alex = Z)
n <- 200 #Set sample size
X <- rnorm(n, 7, 1) #IV: Time spent in grad school (M = 7, SD = 1)
Z <- rnorm(n, 5, 1) #Moderator: Time spent (hours per week) with Professor Demos in class or in office hours (M = 5, SD = 1)
M <- a1*X + a2*Z + a3*X*Z + rnorm(n, 0, .1) #Mediator: Number of publications in grad school
#The mediator variable is created as a function of the IV, moderator, and their interaction with some random noise thrown in the mix
Y <- cdash1*X + cdash2*Z + cdash3*X*Z + b*M + rnorm(n, 0, .1) #DV: Number of job offers
Success.ModMed <- data.frame(jobs = Y, time = X, pubs = M, alex = Z)
library(psych) #Helpful for common psych descriptive statistics
str(Success.ModMed)
round(describe(Success.ModMed)[,c(2:5,8,9,13)], 2)
library(psych) #Helpful for common psych descriptive statistics
round(describe(Success.ModMed)[,c(2:5,8,9,13)], 2)
str(Success.ModMed)
describe(Success.ModMed)
describe(Success.ModMed)[,c(2:5,8,9,13)]
describe(Success.ModMed)
describe(Success.ModMed)[,c(2:5)]
describe(Success.ModMed)[c(2:5)]
str(describe(Success.ModMed))
describe(Success.ModMed)[2:5]
describe(Success.ModMed)
str(Success.ModMed)
library(mediation)
install.packages("mediation")
library(mediation)
Mod.Med.Model.1<-lm(pubs ~ time.c*alex.c, data = Success.ModMed)
Success.ModMed$time.c <- scale(Success.ModMed$time, center = TRUE, scale = FALSE)[,] #Scale returns a matrix so we have to make it a vector by indexing one column
Success.ModMed$alex.c <- scale(Success.ModMed$alex, center = TRUE, scale = FALSE)[,]
#Scale returns a matrix so we have to make it a vector by indexing one column
Success.ModMed$time.c <- scale(Success.ModMed$time, center = TRUE, scale = FALSE)[,]
Success.ModMed$alex.c <- scale(Success.ModMed$alex, center = TRUE, scale = FALSE)[,]
#Scale returns a matrix so we have to make it a vector by indexing one column
scale(Success.ModMed$time, center = TRUE, scale = FALSE)
#Scale returns a matrix so we have to make it a vector by indexing one column
str(scale(Success.ModMed$time, center = TRUE, scale = FALSE))
#Scale returns a matrix so we have to make it a vector by indexing one column
scale(Success.ModMed$time, center = TRUE, scale = FALSE)[]
#Scale returns a matrix so we have to make it a vector by indexing one column
scale(Success.ModMed$time, center = TRUE, scale = FALSE)[,]
#Scale returns a matrix so we have to make it a vector by indexing one column
scale(Success.ModMed$time, center = TRUE, scale = FALSE)
#Scale returns a matrix so we have to make it a vector by indexing one column
scale(Success.ModMed$time, center = TRUE, scale = FALSE)[,]
library(mediation)
Mod.Med.Model.1<-lm(pubs ~ time.c*alex.c, data = Success.ModMed)
summary(Mod.Med.Model.1)
Mod.Med.Model.2<-lm(jobs ~ time.c*alex.c + pubs, data = Success.ModMed)
summary(Mod.Med.Model.2)
Mod.Med.Model.1<-lm(pubs ~ time.c*alex.c, data = Success.ModMed)
summary(Mod.Med.Model.1)
Mod.Med.Model.2<-lm(jobs ~ time.c*alex.c + pubs, data = Success.ModMed)
summary(Mod.Med.Model.2)
mediate <- mediation::mediate
low.alex<-mean(Success.ModMed$alex.c)-sd(Success.ModMed$alex.c)
low.alex
Mod.Med.LowAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2,
covariates = list(alex.c = low.alex), boot = TRUE,
boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")
summary(Mod.Med.LowAlex)
plot(Mod.Med.LowAlex, xlim = 0:1)
high.alex<-mean(Success.ModMed$alex.c)+sd(Success.ModMed$alex.c)
high.alex
Mod.Med.HighAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2,
covariates = list(alex.c = high.alex), boot = TRUE,
boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")
summary(Mod.Med.HighAlex)
plot(Mod.Med.HighAlex, xlim = 0:1)
summary(Mod.Med.HighAlex)
Mod.Med.TestAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2, boot = TRUE,
boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")   #We don't specify anything about the moderator in this code yet
test.modmed(Mod.Med.TestAlex, covariates.1 = list(alex.c = low.alex),
covariates.2 = list(alex.c = high.alex), sims = 10) #Here we specify both levels of the moderator that we want to test
Mod.Med.Lavaan <- '
#Regressions
#These are the same regression equations from our previous example
#Except in this code we are naming the coefficients that are produced from the regression equations
#E.g., the regression coefficient for the effect of time on pubs is named "a1"
pubs ~ a1*time.c + a2*alex.c + a3*time.c:alex.c
jobs ~ cdash1*time.c + cdash2*alex.c + cdash3*time.c:alex.c + b1*pubs
#Mean of centered alex (for use in simple slopes)
#This is making a coefficient labeled "alex.c.mean" which equals the intercept because of the "1"
#(Y~1) gives you the intercept, which is the mean for our alex.c variable
alex.c ~ alex.c.mean*1
#Variance of centered alex (for use in simple slopes)
#This is making a coefficient labeled "alex.c.var" which equals the variance because of the "~~"
#Two tildes separating the same variable gives you the variance
alex.c ~~ alex.c.var*alex.c
#Indirect effects conditional on moderator (a1 + a3*ModValue)*b1
indirect.SDbelow := (a1 + a3*(alex.c.mean-sqrt(alex.c.var)))*b1
indirect.SDabove := (a1 + a3*(alex.c.mean+sqrt(alex.c.var)))*b1
#Direct effects conditional on moderator (cdash1 + cdash3*ModValue)
#We have to do it this way because you cannot call the mean and sd functions in lavaan package
direct.SDbelow := cdash1 + cdash3*(alex.c.mean-sqrt(alex.c.var))
direct.SDabove := cdash1 + cdash3*(alex.c.mean+sqrt(alex.c.var))
#Total effects conditional on moderator
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.SDabove := direct.SDabove + indirect.SDabove
#Proportion mediated conditional on moderator
#To match the output of "mediate" package
prop.mediated.SDbelow := indirect.SDbelow / total.SDbelow
prop.mediated.SDabove := indirect.SDabove / total.SDabove
#Index of moderated mediation
#An alternative way of testing if conditional indirect effects are significantly different from each other
index.mod.med := a3*b1
'
Mod.Med.SEM <- sem(model = Mod.Med.Lavaan,
data = Success.ModMed,
se = "bootstrap",
bootstrap = 10)
summary(Mod.Med.SEM,
fit.measures = FALSE,
standardize = TRUE,
rsquare = TRUE)
#Bootstraps
parameterEstimates(Mod.Med.SEM,
boot.ci.type = "bca.simple",
level = .95, ci = TRUE,
standardized = FALSE)[c(19:27),c(4:10)] #We index the matrix to only display columns we are interested in
set.seed(42)
# path a strength
a=.3
# path b strength
b=.3
# path c' strength
cp=.2
#  people
n <- 300
# Normal distribution of time (mins)
X <- rnorm(n, 5, 2)
# Moderator
Mod<-runif(n, 0, 6)
# Mediator
M <- a*X*Mod+rnorm(n, 0, 3)
# Our equation to  create Y
Y <- cp*X*Mod + b*M + M*Mod + rnorm(n, sd=7)
#Built our data frame
Marshmallow.Mod<-data.frame(Success=Y,Time=X,Trust=M,Parents=Mod)
Marshmallow.Mod$Parents.C<-scale(Marshmallow.Mod$Parents,scale=F)[,]
Marshmallow.Mod$Time.C<-scale(Marshmallow.Mod$Time,scale=F)[,]
Marshmallow.Mod$Trust.C<-scale(Marshmallow.Mod$Trust,scale=F)[,]
ModMed.Mediator<-lm(Trust~Parents.C*Time.C, data= Marshmallow.Mod)
ModMed.Outcome<-lm(Success~Trust.C*Parents.C+Time.C*Parents.C, data= Marshmallow.Mod)
ModMed.Mediator<-lm(Trust~Parents.C*Time.C, data= Marshmallow.Mod)
ModMed.Outcome<-lm(Success~Trust.C*Parents.C+Time.C*Parents.C, data= Marshmallow.Mod)
ModMed.Mediator<-lm(Trust~Parents.C*Time.C, data= Marshmallow.Mod)
ModMed.Outcome<-lm(Success~Trust.C*Parents.C+Time.C*Parents.C, data= Marshmallow.Mod)
library(mediation)
ModMed.Boot.BCa.1 <- mediate(ModMed.Mediator, ModMed.Outcome,
covariates = list(Parents.C = Permissive), boot = TRUE,
boot.ci.type = "bca", sims=200, treat="Time.C", mediator="Trust.C")
Permissive<--sd(Marshmallow.Mod$Parents.C)
Authoritative<-+sd(Marshmallow.Mod$Parents.C)
library(mediation)
ModMed.Boot.BCa.1 <- mediate(ModMed.Mediator, ModMed.Outcome,
covariates = list(Parents.C = Permissive), boot = TRUE,
boot.ci.type = "bca", sims=200, treat="Time.C", mediator="Trust.C")
summary(ModMed.Boot.BCa.1)
plot(ModMed.Boot.BCa.1)
ModMed.Boot.BCa.2 <- mediate(ModMed.Mediator, ModMed.Outcome,
covariates = list(Parents.C = Authoritative), boot = TRUE,
boot.ci.type = "bca", sims=200, treat="Time.C", mediator="Trust.C")
summary(ModMed.Boot.BCa.2)
plot(ModMed.Boot.BCa.2)
ModMed.Boot.BCa.3 <- mediate(ModMed.Mediator, ModMed.Outcome, boot = TRUE,
boot.ci.type = "bca", sims=200, treat="Time.C", mediator="Trust.C")
TestDiff<-test.modmed(ModMed.Boot.BCa.3, covariates.1 = list(Parents.C = Permissive),
covariates.2 = list(Parents.C = Authoritative), sims = 200)
TestDiff
set.seed(42)
# path ab, c' strength
a=.4; b=.4; cp=.2
n <- 177
X <- rnorm(n, 5, 2)
M <- a*X+rnorm(n, 0, 1)
Y <- cp*X + b*M + rnorm(n, sd=1)
Marshmallow.Data.Part<-data.frame(Time=X,Trust=M,Success=Y)
Part.Model.2<-lm(Trust~Time, data= Marshmallow.Data.Part)
Part.Model.3<-lm(Success~Trust+Time, data= Marshmallow.Data.Part)
Part.Med.Boot.BCa <- mediate(Part.Model.2, Part.Model.3, boot = TRUE,
boot.ci.type = "bca", sims=200,
treat="Time", mediator="Trust")
summary(Part.Med.Boot.BCa)
library(lavaan)
hayes4 <- ' # direct effect
Success ~ c*Time
direct := c
# regressions
Trust ~ a*Time
Success ~ b*Trust
# indirect effect (a*b)
indirect := a*b
# total effect
total := c + (a*b)
# Prop
prop := indirect/total'
# fit model
sem4 <- sem(model = hayes4,
data = Marshmallow.Data.Part,
se = "bootstrap",
bootstrap = 200)
#Bootstrap on parameters
SEMResults<-parameterEstimates(sem4,
boot.ci.type = "bca.simple",
level = .95, ci = TRUE,
standardized = FALSE)
SEMResults[c(7:10),c(4:10)] # Note, this is indexed
SEMResults
Marshmallow.Data.Part
SEMResults
set.seed(42) #This makes sure that everyone gets the same numbers generated through rnorm function
a1 = -.59 #Set the path a1 strength (effect of X on M)
a2 = -.17 #Set path a2 strength (effect of Z on M)
a3 = .29 #Set path a3 strength (interaction between X and Z on M)
b = .59 #Set path b strength (effect of M on Y)
cdash1 = .27 #Set path c'1 strength (effect of X on Y)
cdash2 = .01 #Set path c'2 strength (effect of Z on Y)
cdash3 = -.01 #Set path c'3 strength (interaction betwee X and Z on Y)
n <- 200 #Set sample size
X <- rnorm(n, 7, 1) #IV: Time spent in grad school (M = 7, SD = 1)
Z <- rnorm(n, 5, 1) #Moderator: Time spent (hours per week) with Professor Demos in class or in office hours (M = 5, SD = 1)
M <- a1*X + a2*Z + a3*X*Z + rnorm(n, 0, .1) #Mediator: Number of publications in grad school
Y <- cdash1*X + cdash2*Z + cdash3*X*Z + b*M + rnorm(n, 0, .1)
library(psych) #Helpful for common psych descriptive statistics
str(Success.ModMed) #Ex
Success.ModMed <- data.frame(jobs = Y, time = X, pubs = M, alex = Z) #Build our data frame and give it recognizable variable names
str(Success.ModMed) #Ex
describe(Success.ModMed)[,c(2:5,8,9,13)], 2)
describe(Success.ModMed)
Success.ModMed$time.c <- scale(Success.ModMed$time, center = TRUE, scale = FALSE)[,] #Scale returns a matrix so we have to make it a vector by indexing one column
Success.ModMed$alex.c <- scale(Success.ModMed$alex, center = TRUE, scale = FALSE)[,]
mediate <- mediation::mediate #A mediate function is in both the "psych" and "mediation" packages. This allows us to use the correct mediate function from the "mediation" package
Mod.Med.Model.1<-lm(pubs ~ time.c*alex.c, data = Success.ModMed) #This model predicts number of publications from time spent in grad school, time spent with alex, and the interaction between the two
summary(Mod.Med.Model.1)
Mod.Med.Model.2<-lm(jobs ~ time.c*alex.c + pubs, data = Success.ModMed) #This model predicts number of job offers from time spent in grad school, time spent with alex, number of publications, and the interaction between time spent in grad school and time spent with alex
summary(Mod.Med.Model.2)
#Moderator must be in both models for mediate to work.
low.alex<-mean(Success.ModMed$alex.c)-sd(Success.ModMed$alex.c) #Sets our level for 1 SD below mean of alex.c
low.alex #Check value of variable
Mod.Med.LowAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2,
covariates = list(alex.c = low.alex), boot = TRUE,
boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")
summary(Mod.Med.LowAlex)
plot(Mod.Med.LowAlex, xlim = 0:1)
high.alex<-mean(Success.ModMed$alex.c)+sd(Success.ModMed$alex.c)
high.alex
Mod.Med.HighAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2,
covariates = list(alex.c = high.alex), boot = TRUE,
boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")
summary(Mod.Med.HighAlex)
plot(Mod.Med.HighAlex, xlim = 0:1)
Mod.Med.TestAlex <- mediate(Mod.Med.Model.1, Mod.Med.Model.2, boot = TRUE,
boot.ci.type = "bca", sims = 10, treat="time.c", mediator="pubs")   #We don't specify anything about the moderator in this code yet
test.modmed(Mod.Med.TestAlex, covariates.1 = list(alex.c = low.alex),
covariates.2 = list(alex.c = high.alex), sims = 10)
library(lavaan)
Mod.Med.Lavaan <- '
#Regressions
#These are the same regression equations from our previous example
#Except in this code we are naming the coefficients that are produced from the regression equations
#E.g., the regression coefficient for the effect of time on pubs is named "a1"
pubs ~ a1*time.c + a2*alex.c + a3*time.c:alex.c
jobs ~ cdash1*time.c + cdash2*alex.c + cdash3*time.c:alex.c + b1*pubs
#Mean of centered alex (for use in simple slopes)
#This is making a coefficient labeled "alex.c.mean" which equals the intercept because of the "1"
#(Y~1) gives you the intercept, which is the mean for our alex.c variable
alex.c ~ alex.c.mean*1
#Variance of centered alex (for use in simple slopes)
#This is making a coefficient labeled "alex.c.var" which equals the variance because of the "~~"
#Two tildes separating the same variable gives you the variance
alex.c ~~ alex.c.var*alex.c
#Indirect effects conditional on moderator (a1 + a3*ModValue)*b1
indirect.SDbelow := (a1 + a3*(alex.c.mean-sqrt(alex.c.var)))*b1
indirect.SDabove := (a1 + a3*(alex.c.mean+sqrt(alex.c.var)))*b1
#Direct effects conditional on moderator (cdash1 + cdash3*ModValue)
#We have to do it this way because you cannot call the mean and sd functions in lavaan package
direct.SDbelow := cdash1 + cdash3*(alex.c.mean-sqrt(alex.c.var))
direct.SDabove := cdash1 + cdash3*(alex.c.mean+sqrt(alex.c.var))
#Total effects conditional on moderator
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.SDabove := direct.SDabove + indirect.SDabove
#Proportion mediated conditional on moderator
#To match the output of "mediate" package
prop.mediated.SDbelow := indirect.SDbelow / total.SDbelow
prop.mediated.SDabove := indirect.SDabove / total.SDabove
#Index of moderated mediation
#An alternative way of testing if conditional indirect effects are significantly different from each other
index.mod.med := a3*b1
'
Mod.Med.Lavaan <- '
#Regressions
#These are the same regression equations from our previous example
#Except in this code we are naming the coefficients that are produced from the regression equations
#E.g., the regression coefficient for the effect of time on pubs is named "a1"
pubs ~ a1*time.c + a2*alex.c + a3*time.c:alex.c
jobs ~ cdash1*time.c + cdash2*alex.c + cdash3*time.c:alex.c + b1*pubs
#Mean of centered alex (for use in simple slopes)
#This is making a coefficient labeled "alex.c.mean" which equals the intercept because of the "1"
#(Y~1) gives you the intercept, which is the mean for our alex.c variable
alex.c ~ alex.c.mean*1
#Variance of centered alex (for use in simple slopes)
#This is making a coefficient labeled "alex.c.var" which equals the variance because of the "~~"
#Two tildes separating the same variable gives you the variance
alex.c ~~ alex.c.var*alex.c
#Indirect effects conditional on moderator (a1 + a3*ModValue)*b1
indirect.SDbelow := (a1 + a3*(alex.c.mean-sqrt(alex.c.var)))*b1
indirect.SDabove := (a1 + a3*(alex.c.mean+sqrt(alex.c.var)))*b1
#Direct effects conditional on moderator (cdash1 + cdash3*ModValue)
#We have to do it this way because you cannot call the mean and sd functions in lavaan package
direct.SDbelow := cdash1 + cdash3*(alex.c.mean-sqrt(alex.c.var))
direct.SDabove := cdash1 + cdash3*(alex.c.mean+sqrt(alex.c.var))
#Total effects conditional on moderator
total.SDbelow := direct.SDbelow + indirect.SDbelow
total.SDabove := direct.SDabove + indirect.SDabove
#Proportion mediated conditional on moderator
#To match the output of "mediate" package
prop.mediated.SDbelow := indirect.SDbelow / total.SDbelow
prop.mediated.SDabove := indirect.SDabove / total.SDabove
#Index of moderated mediation
#An alternative way of testing if conditional indirect effects are significantly different from each other
index.mod.med := a3*b1
'
Mod.Med.SEM <- sem(model = Mod.Med.Lavaan,
data = Success.ModMed,
se = "bootstrap",
bootstrap = 10)
#Fit measures
summary(Mod.Med.SEM,
fit.measures = FALSE,
standardize = TRUE,
rsquare = TRUE)
#Bootstraps
parameterEstimates(Mod.Med.SEM,
boot.ci.type = "bca.simple",
level = .95, ci = TRUE,
standardized = FALSE)[c(19:27),c(4:10)] #We index the matrix to only display columns we are interested in
str(Success.ModMed)
library(semMediation)
